var documenterSearchIndex = {"docs":
[{"location":"examples/sir-basic/","page":"Basic SIR example","title":"Basic SIR example","text":"EditURL = \"https://github.com/slwu89/Individual.jl/blob/main/examples/sir-basic.jl\"","category":"page"},{"location":"examples/sir-basic/#sir_basic","page":"Basic SIR example","title":"Basic SIR example","text":"","category":"section"},{"location":"examples/sir-basic/","page":"Basic SIR example","title":"Basic SIR example","text":"Sean L. Wu (@slwu89), 2021-1-8","category":"page"},{"location":"examples/sir-basic/","page":"Basic SIR example","title":"Basic SIR example","text":"using Individual.Sampling\nusing Individual.SchemaBase\n\nusing Catlab.Present, Catlab.CSetDataStructures, Catlab.Theories, Catlab.CategoricalAlgebra, Catlab.Graphics, Catlab.Graphs\nusing Plots\nusing GraphViz","category":"page"},{"location":"examples/sir-basic/#Introduction","page":"Basic SIR example","title":"Introduction","text":"","category":"section"},{"location":"examples/sir-basic/","page":"Basic SIR example","title":"Basic SIR example","text":"The SIR (Susceptible-Infected-Recovered) model is the \"hello, world!\" model of for infectious disease simulations, and here we describe how to use the basic schema for Markov models to build it in Individual.jl. We only use the base TheoryIBM schema, because the model is a Markov chain. This tutorial largely mirrors the SIR model tutorial from the R package \"individual\", which inspired individual.jl.","category":"page"},{"location":"examples/sir-basic/","page":"Basic SIR example","title":"Basic SIR example","text":"For more information about the SIR model and stochastic epidemic models in general, please see \"A primer on stochastic epidemic models: Formulation, numerical simulation, and analysis\".","category":"page"},{"location":"examples/sir-basic/","page":"Basic SIR example","title":"Basic SIR example","text":"The schema looks like this:","category":"page"},{"location":"examples/sir-basic/","page":"Basic SIR example","title":"Basic SIR example","text":"to_graphviz(TheoryIBM)","category":"page"},{"location":"examples/sir-basic/","page":"Basic SIR example","title":"Basic SIR example","text":"There are morphisms from the object Person into State. The first, state gives the current state of each individual in the simulation. The second state_update is where state updates can be queued; at the end of a time step, state is swapped with state_update and state_update is reset. This ensures that state updates obey a FIFO order, and that individuals update synchronously.","category":"page"},{"location":"examples/sir-basic/","page":"Basic SIR example","title":"Basic SIR example","text":"There are also labels for states to make it easier to write self-documenting models.","category":"page"},{"location":"examples/sir-basic/","page":"Basic SIR example","title":"Basic SIR example","text":"The basic schema could be extended with further Attrs if needing to model individual level heterogeneity, like immmune respose, etc.","category":"page"},{"location":"examples/sir-basic/","page":"Basic SIR example","title":"Basic SIR example","text":"When extending the schema with combinatorial states (i.e. categorical states, like further stratification of compartments), these are best set up as more objects Ob in your schema, which should inherit from TheoryIBM or TheorySchedulingIBM (see the article \"SIR example with age structure\" for an example of extending a schema). You might want to add Attr (attributes) to your schema if each person in your simulation has associated atomic data, such as floating point (real) variables, of more complex data structures associated with them. In either case, if the added object or attribute is not static, add a duplicate Hom or Attr with the same name but ending in \"update\". That was `simulationloopknows to grab copy the \"_update\" object or attribute into the one containins the current state at the end of the time step. For example, you might add anotherOb\"risk\", and \"risk_update\", to which you could add updates using the ACSet interface functionset_subpart!`.","category":"page"},{"location":"examples/sir-basic/#Parameters","page":"Basic SIR example","title":"Parameters","text":"","category":"section"},{"location":"examples/sir-basic/","page":"Basic SIR example","title":"Basic SIR example","text":"To start, we should define some parameters. The epidemic will be simulated in a population of 1000, where 8 persons are initially infectious, whose indices are randomly sampled. The effective contact rate β will be a function of the deterministic R0 and recovery rate γ. We also specify Δt, which is the size of the time step. Because individual’s time steps are all of unit length, we scale transition probabilities by Δt to create models with different sized steps, interpreting the discrete time model as a discretization of a continuous time model. If the maximum time is tmax then the overall number of time steps is tmax/Δt.","category":"page"},{"location":"examples/sir-basic/","page":"Basic SIR example","title":"Basic SIR example","text":"N = 1000\nI0 = 8\nS0 = N - I0\nΔt = 0.1\ntmax = 100\nsteps = Int(tmax/Δt)\nγ = 1/10 # recovery rate\nR0 = 2.5\nβ = R0 * γ # R0 for corresponding ODEs\n\ninitial_states = fill(\"S\", N)\ninitial_states[rand(1:N, I0)] .= \"I\"\nstate_labels = [\"S\", \"I\", \"R\"];\nnothing #hide","category":"page"},{"location":"examples/sir-basic/#Model-object","page":"Basic SIR example","title":"Model object","text":"","category":"section"},{"location":"examples/sir-basic/","page":"Basic SIR example","title":"Basic SIR example","text":"The \"IBM\" (Individual Based Model) schema needs the type parameter String because it defines a single attribute, that giving names to the categorical set of states.","category":"page"},{"location":"examples/sir-basic/","page":"Basic SIR example","title":"Basic SIR example","text":"const SIR = IBM{String}()\ninitialize_states(SIR, initial_states, state_labels);\nnothing #hide","category":"page"},{"location":"examples/sir-basic/#Processes","page":"Basic SIR example","title":"Processes","text":"","category":"section"},{"location":"examples/sir-basic/","page":"Basic SIR example","title":"Basic SIR example","text":"In order to model infection, we need a process. This is a function that takes only a single argument, t, for the current time step (unused here, but can model time-dependent processes, such as seasonality or school holiday). Within the function, we get the current number of infectious individuals, then calculate the per-capita force of infection on each susceptible person, λ=βI/N. Next we get the set of susceptible individuals and use the sample method to randomly select those who will be infected on this time step. The probability is given by $ 1- e^{-\\lambda \\Delta t} $. The method bernoulli_sample will automatically calculate that probability when given 3 arguments. Finally, we queue a state update for those individuals who were sampled.","category":"page"},{"location":"examples/sir-basic/","page":"Basic SIR example","title":"Basic SIR example","text":"function infection_process(t::Int)\n    I = npeople(SIR, \"I\")\n    N = npeople(SIR)\n    λ = β * I/N\n    S = get_index_state(SIR, \"S\")\n    S = bernoulli_sample(S, λ, Δt)\n    queue_state_update(SIR, S, \"I\")\nend","category":"page"},{"location":"examples/sir-basic/","page":"Basic SIR example","title":"Basic SIR example","text":"The recovery process is simpler, as the per-capita transition probability from I to R does not depend on the state of the system.","category":"page"},{"location":"examples/sir-basic/","page":"Basic SIR example","title":"Basic SIR example","text":"function recovery_process(t::Int)\n    I = get_index_state(SIR, \"I\")\n    I = bernoulli_sample(I, γ, Δt)\n    queue_state_update(SIR, I, \"R\")\nend","category":"page"},{"location":"examples/sir-basic/#Simulation","page":"Basic SIR example","title":"Simulation","text":"","category":"section"},{"location":"examples/sir-basic/","page":"Basic SIR example","title":"Basic SIR example","text":"We use render_process to create a rendering (output) process and a matrix giving state counts by time step.","category":"page"},{"location":"examples/sir-basic/","page":"Basic SIR example","title":"Basic SIR example","text":"Then we draw a trajectory using simulation_loop and plot the results. Please note that simulation_loop is a simple wrapper around the correct updating order and that a user can always write a simple for loop to update the model.","category":"page"},{"location":"examples/sir-basic/","page":"Basic SIR example","title":"Basic SIR example","text":"state_out, render_process = render_states(SIR, steps)\n\nsimulation_loop(SIR, [infection_process, recovery_process, render_process], steps)\n\nplot(\n    (1:steps) * Δt,\n    state_out,\n    label=[\"S\" \"I\" \"R\"],\n    xlabel=\"Time\",\n    ylabel=\"Number\"\n)","category":"page"},{"location":"api/#ref_api","page":"Library Reference","title":"API reference","text":"","category":"section"},{"location":"api/#Basic-schema","page":"Library Reference","title":"Basic schema","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Functions to create basic Markov individual-based models (IBM).","category":"page"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Individual.SchemaBase.TheoryIBM\nIndividual.SchemaBase.AbstractIBM\nIndividual.SchemaBase.IBM\nIndividual.SchemaBase.npeople\nIndividual.SchemaBase.nstate\nIndividual.SchemaBase.statelabel\nIndividual.SchemaBase.get_index_state\nIndividual.SchemaBase.queue_state_update\nIndividual.SchemaBase.render_states\nIndividual.SchemaBase.initialize_states\nIndividual.SchemaBase.reset_states\nIndividual.SchemaBase.create_state_update\nIndividual.SchemaBase.create_attr_update\nIndividual.SchemaBase.simulation_loop","category":"page"},{"location":"api/#Individual.SchemaBase.TheoryIBM","page":"Library Reference","title":"Individual.SchemaBase.TheoryIBM","text":"ACSet definition for a basic individual-based model     See Catlab.jl documentation      for description of the @present syntax.    \n\n\n\n\n\n","category":"constant"},{"location":"api/#Individual.SchemaBase.AbstractIBM","page":"Library Reference","title":"Individual.SchemaBase.AbstractIBM","text":"An abstract ACSet for a basic Markov individual-based model.\n\n\n\n\n\n","category":"type"},{"location":"api/#Individual.SchemaBase.IBM","page":"Library Reference","title":"Individual.SchemaBase.IBM","text":"A concrete ACSet for a basic Markov individual-based model inheriting from AbstractIBM.\n\n\n\n\n\n","category":"type"},{"location":"api/#Individual.SchemaBase.npeople","page":"Library Reference","title":"Individual.SchemaBase.npeople","text":"npeople(model::AbstractIBM, states)\n\nReturn the number of people in some set of states (an element of the State Ob). If called without the argument states, simply return the total population size.\n\n\n\n\n\n","category":"function"},{"location":"api/#Individual.SchemaBase.nstate","page":"Library Reference","title":"Individual.SchemaBase.nstate","text":"nstate(model::AbstractIBM)\n\nReturn the size of the finite state space.\n\n\n\n\n\n","category":"function"},{"location":"api/#Individual.SchemaBase.statelabel","page":"Library Reference","title":"Individual.SchemaBase.statelabel","text":"statelabel(model::AbstractIBM)\n\nReturn the labels (names) of the states in the finite state space.\n\n\n\n\n\n","category":"function"},{"location":"api/#Individual.SchemaBase.get_index_state","page":"Library Reference","title":"Individual.SchemaBase.get_index_state","text":"get_index_state(model::AbstractIBM, states)\n\nReturn an integer vector giving the persons who are in the states specified in states. If called without the argument states, simply return everyone's index.\n\n\n\n\n\n","category":"function"},{"location":"api/#Individual.SchemaBase.queue_state_update","page":"Library Reference","title":"Individual.SchemaBase.queue_state_update","text":"queue_state_update(model::AbstractIBM, persons, state)\n\nFor persons specified in persons, queue a state update to state, which will be applied at the end of the time step.\n\n\n\n\n\n","category":"function"},{"location":"api/#Individual.SchemaBase.render_states","page":"Library Reference","title":"Individual.SchemaBase.render_states","text":"render_states(model::AbstractIBM, steps::Integer)\n\nReturn a tuple whose first element is a matrix containing counts of states (columns) by time step (rows), and whose second element is a process function which can be used in the simulation loop.\n\n\n\n\n\n","category":"function"},{"location":"api/#Individual.SchemaBase.initialize_states","page":"Library Reference","title":"Individual.SchemaBase.initialize_states","text":"initialize_states(model::AbstractIBM, initial_states, state_labels::Vector{String})\n\nInitialize the categorical states of a model. The argument initial_states can either be provided as a vector of integers, corresponding to the internal storage of the ACSet, or as a vector of strings. It should be equal in length to the population which is to be simulated.\n\n\n\n\n\n","category":"function"},{"location":"api/#Individual.SchemaBase.reset_states","page":"Library Reference","title":"Individual.SchemaBase.reset_states","text":"initialize_states(model::AbstractIBM, initial_states)\n\nReset a model's categorical states.\n\n\n\n\n\n","category":"function"},{"location":"api/#Individual.SchemaBase.create_state_update","page":"Library Reference","title":"Individual.SchemaBase.create_state_update","text":"create_state_update(model::AbstractIBM)\n\nReturn a function that is called with no arguments that updates any Ob that has an accompanying update Ob. For example, if you provide both risk and risk_update, then risk_update will be used to update risk and then cleared.\n\n\n\n\n\n","category":"function"},{"location":"api/#Individual.SchemaBase.create_attr_update","page":"Library Reference","title":"Individual.SchemaBase.create_attr_update","text":"createattrupdate(model::AbstractIBM)\n\nReturn a function that is called with no arguments that updates any Attr that has an accompanying update Attr. For example, if you provide both antibody and antibody_titre as Attr objects from Person to the apropriate AttrType, this function will update antibody to the values in antibody_titre on each time step. This requires that when the model is initialized, each attribute and its update have approximately the same starting values.\n\n\n\n\n\n","category":"function"},{"location":"api/#Individual.SchemaBase.simulation_loop","page":"Library Reference","title":"Individual.SchemaBase.simulation_loop","text":"simulation_loop(model::AbstractIBM, processes::Union{Function, AbstractVector{Function}}, steps::Integer)\n\nA simple predefined simulation loop for basic (no events) individual based models. Processes are called first, followed by state updates.\n\n\n\n\n\nsimulation_loop(model::AbstractIBM, processes::Union{Function, AbstractVector{Function}}, steps::Integer)\n\nA method for simulation models with event scheduling.\n\n\n\n\n\n","category":"function"},{"location":"api/#Event-scheduling-schema","page":"Library Reference","title":"Event scheduling schema","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Create IBMs with event scheduling capabilities.","category":"page"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Individual.SchemaEvents.TheorySchedulingIBM\nIndividual.SchemaEvents.AbstractSchedulingIBM\nIndividual.SchemaEvents.SchedulingIBM\nIndividual.SchemaEvents.add_event\nIndividual.SchemaEvents.schedule_event\nIndividual.SchemaEvents.get_scheduled\nIndividual.SchemaEvents.clear_schedule\nIndividual.SchemaEvents.event_tick\nIndividual.SchemaEvents.event_process","category":"page"},{"location":"api/#Individual.SchemaEvents.TheorySchedulingIBM","page":"Library Reference","title":"Individual.SchemaEvents.TheorySchedulingIBM","text":"A schema for an individual-based model inheriting from TheoryIBM     which allows for events to be scheduled for persons.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Individual.SchemaEvents.AbstractSchedulingIBM","page":"Library Reference","title":"Individual.SchemaEvents.AbstractSchedulingIBM","text":"An abstract ACSet for an individual-based model inheriting from AbstractIBM     which allows for events to be scheduled for persons.\n\n\n\n\n\n","category":"type"},{"location":"api/#Individual.SchemaEvents.SchedulingIBM","page":"Library Reference","title":"Individual.SchemaEvents.SchedulingIBM","text":"A concrete ACSet for an individual-based model inheriting from AbstractSchedulingIBM which allows for events to be scheduled for persons.\n\n\n\n\n\n","category":"type"},{"location":"api/#Individual.SchemaEvents.add_event","page":"Library Reference","title":"Individual.SchemaEvents.add_event","text":"add_event(model::AbstractSchedulingIBM, label::String, listeners...)\n\nAdd an event to the model, with name 'label',\n\n\n\n\n\n","category":"function"},{"location":"api/#Individual.SchemaEvents.schedule_event","page":"Library Reference","title":"Individual.SchemaEvents.schedule_event","text":"schedule_event(model::AbstractSchedulingIBM, target, delay, event)\n\nSchedule a set of persons in target for the event after some delay. Note that event should correspond to an element in the set EventLabel in your model.\n\n\n\n\n\n","category":"function"},{"location":"api/#Individual.SchemaEvents.get_scheduled","page":"Library Reference","title":"Individual.SchemaEvents.get_scheduled","text":"get_scheduled(model::AbstractSchedulingIBM, event)\n\nGet the set of persons scheduled for event. Note that event should correspond to an element in the set EventLabel in your model.\n\n\n\n\n\n","category":"function"},{"location":"api/#Individual.SchemaEvents.clear_schedule","page":"Library Reference","title":"Individual.SchemaEvents.clear_schedule","text":"clear_schedule(model::AbstractSchedulingIBM, target)\n\nClear the persons in target from any events they are scheduled for. If 'target' is not specified, clear all scheduled events.\n\n\n\n\n\n","category":"function"},{"location":"api/#Individual.SchemaEvents.event_tick","page":"Library Reference","title":"Individual.SchemaEvents.event_tick","text":"event_tick(model::AbstractSchedulingIBM)\n\nReduce all delays by 1, called at the end of a time step.\n\n\n\n\n\n","category":"function"},{"location":"api/#Individual.SchemaEvents.event_process","page":"Library Reference","title":"Individual.SchemaEvents.event_process","text":"event_process(model::AbstractSchedulingIBM, t::Int)\n\nProcess events which are ready to fire.\n\n\n\n\n\n","category":"function"},{"location":"api/#Sampling","page":"Library Reference","title":"Sampling","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Methods for Sampling random variates commonly used in IBMs.","category":"page"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Individual.Sampling.delay_geom_sample\nIndividual.Sampling.bernoulli_sample\nIndividual.Sampling.choose","category":"page"},{"location":"api/#Individual.Sampling.delay_geom_sample","page":"Library Reference","title":"Individual.Sampling.delay_geom_sample","text":"delay_geom_sample(n::Integer, rate::AbstractFloat, dt::AbstractFloat)\n\nSample time steps until an event fires given a rate and dt where the waiting time follows a Geometric distribution. The minimum delay is 1, otherwise there could be \"instantaneous\" events, which are better (more efficiently) simulated as processes.\n\n\n\n\n\n","category":"function"},{"location":"api/#Individual.Sampling.bernoulli_sample","page":"Library Reference","title":"Individual.Sampling.bernoulli_sample","text":"bernoulli_sample(target::AbstractVector, prob::AbstractFloat)\n\nSample without replacement from target with success probability prob.\n\n\n\n\n\nbernoulli_sample(target::AbstractVector, rate::AbstractFloat, dt::AbstractFloat)\n\nSample without replacement from target with success probability calculated from 1 - e^-mathrmrate * mathrmdt\n\n\n\n\n\nbernoulli_sample(target::AbstractVector{T}, prob::Vector{R})\n\nSample without replacement from target where each element has a unique success probability  given in the vector prob.\n\n\n\n\n\nbernoulli_sample(target::AbstractVector{T}, rate::Vector{R}, dt::AbstractFloat)\n\nSample without replacement from target where each element's success probability is calculated from 1 - e^-mathrmrate * mathrmdt.\n\n\n\n\n\n","category":"function"},{"location":"api/#Individual.Sampling.choose","page":"Library Reference","title":"Individual.Sampling.choose","text":"choose(target::T, K::Integer) where {T <: Integer}\nchoose(target::AbstractVector{T}, K::Integer) where {T <: Integer}\n\nReturn a vector of size K with that number of random elements selected without replacement from target.\n\n\n\n\n\n","category":"function"},{"location":"examples/sir-age/","page":"SIR example with age structure","title":"SIR example with age structure","text":"EditURL = \"https://github.com/slwu89/Individual.jl/blob/main/examples/sir-age.jl\"","category":"page"},{"location":"examples/sir-age/#sir_age","page":"SIR example with age structure","title":"SIR example with age structure","text":"","category":"section"},{"location":"examples/sir-age/","page":"SIR example with age structure","title":"SIR example with age structure","text":"Sean L. Wu (@slwu89), 2021-1-22","category":"page"},{"location":"examples/sir-age/","page":"SIR example with age structure","title":"SIR example with age structure","text":"using Individual.Sampling\nusing Individual.SchemaBase\n\nusing Catlab.Present, Catlab.CSetDataStructures, Catlab.Theories, Catlab.CategoricalAlgebra, Catlab.Graphics, Catlab.Graphs\nusing Plots\nusing LinearAlgebra\nusing Random\nusing GraphViz","category":"page"},{"location":"examples/sir-age/#Introduction","page":"SIR example with age structure","title":"Introduction","text":"","category":"section"},{"location":"examples/sir-age/","page":"SIR example with age structure","title":"SIR example with age structure","text":"This tutorial shows how to extend the existing abstract ACSet types to incorporate an additional attribute for modeling age structure. The model is an age-structured SIR model where the force of infection experienced by an individual is the sum of their effective contacts with each age group. The contact matrix C_ij gives the number of daily contacts a person in age group i has with persons in age group j.","category":"page"},{"location":"examples/sir-age/#Schema","page":"SIR example with age structure","title":"Schema","text":"","category":"section"},{"location":"examples/sir-age/","page":"SIR example with age structure","title":"SIR example with age structure","text":"We need to define a new schema inheriting from TheoryIBM. Please note that when we use @acset_type to define the type for the ACSet data structure for our model, we need to set :statelabel as a unique index. This is because the simulation framework assumes that there is a one to one mapping between states and their unique labels. Please look at the type definition for IBM and SchedulingIBM in the source files to see what indices are expected, and the ACSet documentation in Catlab.jl for more information about these data types.","category":"page"},{"location":"examples/sir-age/","page":"SIR example with age structure","title":"SIR example with age structure","text":"@present TheoryAgeIBM <: TheoryIBM begin\n    Age::AttrType\n    age::Attr(Person, Age)\nend\n\n@abstract_acset_type AbstractAgeIBM <: AbstractIBM\n@acset_type AgeIBM(TheoryAgeIBM, index = [:state, :state_update, :age], unique_index = [:statelabel]) <: AbstractAgeIBM","category":"page"},{"location":"examples/sir-age/","page":"SIR example with age structure","title":"SIR example with age structure","text":"The schema looks like this. Note that there is an additional attribute in the schema, for age of each individual. Note that because age bin will not change over the short course of the epidemic, we don't add another Attr \"age_update\".","category":"page"},{"location":"examples/sir-age/","page":"SIR example with age structure","title":"SIR example with age structure","text":"to_graphviz(TheoryAgeIBM)","category":"page"},{"location":"examples/sir-age/#Parameters","page":"SIR example with age structure","title":"Parameters","text":"","category":"section"},{"location":"examples/sir-age/","page":"SIR example with age structure","title":"SIR example with age structure","text":"To parameterize the model from R_0 and gamma, we follow the method from \"Social contact patterns and control strategies for influenza in the elderly\". where R_0 is beta  gamma multiplied by the largest eigenvalue of the reciprocal (symmetric) contact matrix. Note that the interpretation of beta is slightly different in the age-structured model; here it is only the probability of infection given infectious contact, in the other examples it was the rate of contact multiplied by the probability of infection given infectious contact.","category":"page"},{"location":"examples/sir-age/","page":"SIR example with age structure","title":"SIR example with age structure","text":"We use the estimated contact matrix for Taiwan from \"Projecting social contact matrices in 152 countries using contact surveys and demographic data\", given in contact_unnorm. There are 16 age groups, in 5 year bins, up to age 75, at which all remaining persons are included in the last bin. Because the contact matrix is directly estimated from survey data, it is not reciprocal (i.e. the number of contacts sent from age group i to j must equal the number from j to i). We use a simple pairwise correction to generate a reciprocal contact matrix. For more information on reciprocity in parameterizing contact matrices, please see the article \"Projecting social contact matrices to different demographic structures\".","category":"page"},{"location":"examples/sir-age/","page":"SIR example with age structure","title":"SIR example with age structure","text":"The vector pop_TW_actual gives the census population in 16 bins, which we scale to our population N.","category":"page"},{"location":"examples/sir-age/","page":"SIR example with age structure","title":"SIR example with age structure","text":"N = 1000\nI0 = 8\nS0 = N - I0\nΔt = 0.1\ntmax = 100\nsteps = Int(tmax/Δt)\nγ = 1/10 # recovery rate\nR0 = 2.5\n\npop_TW_actual = [1011137, 1041749, 975803, 1213008, 1502279, 1618075, 1621625, 1926961, 2032452, 1755391, 1806638, 1852580, 1684376, 1416638, 903130, 1454933]\npop_TW = N * (pop_TW_actual / sum(pop_TW_actual))\npop_TW = Int.(round.(pop_TW))\nN_ages = Float64.(pop_TW)\n\ncontact_unnorm = [1.13133995414878\t0.557101193757009\t0.277403588569526\t0.166283484217312\t0.243637116538954\t0.501429856885401\t0.773456505042611\t0.664734678057495\t0.373030323264845\t0.207403718009079\t0.219768245286902\t0.183713318566528\t0.100598824431586\t0.0723635363224441\t0.0451987854057666\t0.0264190015627899\n0.522116359073187\t5.13993582380529\t0.999881750990576\t0.256872404884024\t0.152965888814777\t0.440037571740546\t0.81718457664922\t0.901816339582795\t0.776770796127256\t0.324978689513501\t0.203946781656598\t0.170308924697168\t0.114410112258284\t0.0766043987718478\t0.0377257124824009\t0.0309979523804595\n0.233720556183555\t1.92985936809443\t11.0692392115508\t0.983950046684279\t0.331933259964229\t0.36113787699594\t0.563341231085396\t0.903032808933502\t1.17790738474796\t0.651636521136264\t0.342842258726613\t0.173034004951767\t0.085317189948624\t0.0792891389004607\t0.0627981424580935\t0.0524757101169723\n0.117682987086876\t0.345910173819922\t3.30103123371644\t10.0791939893023\t1.50916450884044\t0.791285884658043\t0.640497694236322\t0.824953404104752\t1.08583985409548\t1.09515652926247\t0.535792916941561\t0.197364288066501\t0.0713874830715285\t0.0516466911367817\t0.0315463617042823\t0.0232625811949096\n0.184283846973784\t0.180619839511097\t0.291480297355471\t2.42727014100382\t4.36737726042213\t2.04934997728767\t1.39723781506946\t1.20032801881538\t1.01070904475343\t1.23524796447696\t0.800832127889001\t0.39902019518293\t0.0944429030797382\t0.0416382822716035\t0.0470826453808244\t0.0394951197797532\n0.56156192817194\t0.342992537769556\t0.200122810772951\t0.916989232128664\t2.3980129020946\t4.30977975618343\t2.22681401915761\t1.59261033191491\t1.30238635661337\t1.05207634128304\t1.00949814315475\t0.536928086612407\t0.168547286689823\t0.0624501078266029\t0.0317257423796732\t0.0269431049949397\n0.817794867047499\t1.1441520682733\t0.841196707142586\t0.551555851206977\t1.22865834990464\t2.17367993548303\t3.72979423098863\t2.14929466728635\t1.55306730764128\t1.11703404262428\t0.859302034849221\t0.601599257124208\t0.256942068421412\t0.106203837431624\t0.0555526815130332\t0.0511357782774989\n0.665898107120277\t1.15314199919716\t0.9740043186808\t0.697233734859189\t0.825555277703876\t1.54165452016297\t1.99243882433986\t3.25956559702894\t2.06558139725526\t1.22850364764608\t0.791670106907652\t0.438605150114473\t0.244794735730732\t0.148777023280774\t0.0869686510606626\t0.0349673148163165\n0.344192143343282\t0.807995410469339\t1.14415043227526\t1.22438695056131\t0.988030619038175\t1.30424464223099\t1.72028688625099\t1.87814450829015\t2.90470388452872\t1.49758830410338\t0.934324050254837\t0.330600903622231\t0.182537686520201\t0.114580140863156\t0.0813846406012246\t0.0400784886603155\n0.235791530653026\t0.585194161111923\t0.776189668181761\t1.67596626847397\t0.98479644076933\t1.01459833535067\t1.25482711892082\t1.36074838781177\t1.44439037412333\t2.06915205205562\t0.978401494457824\t0.39999986541145\t0.147110687316517\t0.0835852658511084\t0.0775170890988546\t0.0761516911425131\n0.247247471139332\t0.643310594857866\t1.05811260803268\t1.31212557944165\t1.09555967723574\t1.35073741525286\t1.16660463514035\t1.06882688561953\t1.37118566862\t1.49192984016939\t1.73933382380217\t0.740193371293642\t0.243542236335681\t0.109266882350377\t0.0798121160310869\t0.0833033422190585\n0.442684358021657\t0.702087727411373\t0.662177052932204\t0.816859526244507\t0.738982978496004\t1.2358668685183\t1.27567127460055\t0.896236373088294\t0.950326986928672\t0.797183567958301\t1.02749599715298\t1.51681655407295\t0.451707898396268\t0.195099577202936\t0.0961333966552319\t0.0769572529007728\n0.327638342195265\t0.328285016941782\t0.238165901349415\t0.354821937305308\t0.320966945158153\t0.529029787102833\t0.677350792373831\t0.650949037046765\t0.501900491233428\t0.407240319726415\t0.395920768113556\t0.541100083728198\t0.836769891969799\t0.267847588746602\t0.145638827229407\t0.059691205799689\n0.193568331575816\t0.313138348784034\t0.2640962452464\t0.160094097408356\t0.204553272242237\t0.325505767060564\t0.516407578574901\t0.473341415992634\t0.438186035505819\t0.281001067157269\t0.296302451590512\t0.375946282497057\t0.331749859023468\t0.679792406234649\t0.173000119847818\t0.0702778253123571\n0.0963863876721027\t0.282393513167451\t0.295599962015119\t0.30895124164141\t0.1384465024105\t0.257953175229946\t0.27963826844241\t0.436956466193058\t0.509042820432503\t0.403187215044375\t0.316140357668137\t0.277393058839257\t0.385660305905714\t0.370945733661385\t0.606083091791185\t0.185944796718132\n0.188903590501605\t0.259894019899239\t0.37803587788717\t0.31873977192663\t0.125868047138266\t0.160125548829692\t0.269195296463481\t0.305611946209338\t0.348244256184042\t0.390220623327373\t0.393237304756271\t0.240097073151863\t0.144076910885202\t0.19701354194507\t0.184345002762545\t0.325239463933643];\n\ncontact = (contact_unnorm + transpose(contact_unnorm) .* ( pop_TW * transpose(1 ./ pop_TW))) ./ 2\n\nC = contact\nfor i = 1:16\n    for j = 1:16\n        C[i,j] = contact[i,j]*N_ages[i]/N_ages[j]\n    end\nend\n\nβ = R0 * γ / max(eigvals(C)...);\nnothing #hide","category":"page"},{"location":"examples/sir-age/","page":"SIR example with age structure","title":"SIR example with age structure","text":"The initial states are the same as the other tutorials, 1000 individuals, 8 of whom are intially infected.","category":"page"},{"location":"examples/sir-age/","page":"SIR example with age structure","title":"SIR example with age structure","text":"initial_states = fill(\"S\", N)\ninitial_states[rand(1:N, I0)] .= \"I\"\nstate_labels = [\"S\", \"I\", \"R\"];\nnothing #hide","category":"page"},{"location":"examples/sir-age/#Model-object","page":"SIR example with age structure","title":"Model object","text":"","category":"section"},{"location":"examples/sir-age/","page":"SIR example with age structure","title":"SIR example with age structure","text":"The AgeIBM schema we made needs two type parameters. The first String is for the set of state labels, inherited from IBM. The second is for the age attribute. Because age is discretized into bins to match the survey data used to parameterize the contact matrix, the attribute type is an integer.","category":"page"},{"location":"examples/sir-age/","page":"SIR example with age structure","title":"SIR example with age structure","text":"const SIR = AgeIBM{String, Int64}()\ninitialize_states(SIR, initial_states, state_labels);\nnothing #hide","category":"page"},{"location":"examples/sir-age/","page":"SIR example with age structure","title":"SIR example with age structure","text":"We need to sample the age bins for each person, such that the sizes of each age bin are correct.","category":"page"},{"location":"examples/sir-age/","page":"SIR example with age structure","title":"SIR example with age structure","text":"ages = vcat([fill(i, pop_TW[i]) for i in 1:16]...)\nshuffle!(ages)\nset_subpart!(SIR, 1:N, :age, ages);\nnothing #hide","category":"page"},{"location":"examples/sir-age/#Processes","page":"SIR example with age structure","title":"Processes","text":"","category":"section"},{"location":"examples/sir-age/","page":"SIR example with age structure","title":"SIR example with age structure","text":"The force of infection on a person in age class i is computed according to:","category":"page"},{"location":"examples/sir-age/","page":"SIR example with age structure","title":"SIR example with age structure","text":" lambda_i = beta sumlimits_j C_ij left( fracI_jN_j right)","category":"page"},{"location":"examples/sir-age/","page":"SIR example with age structure","title":"SIR example with age structure","text":"We use a helper function tabulate_ages to calculate the infectious population sizes I_j.","category":"page"},{"location":"examples/sir-age/","page":"SIR example with age structure","title":"SIR example with age structure","text":"function tabulate_ages(ages_vec)\n    [Float64(sum(ages_vec .== i)) for i = 1:16]\nend\n\nfunction infection_process(t::Int)\n    I = get_index_state(SIR, \"I\")\n    I_ages = subpart(SIR, I, :age)\n    I_ages = tabulate_ages(I_ages)\n\n    λ = β * sum(C * diagm(I_ages ./ N_ages), dims = 2)\n\n    S = get_index_state(SIR, \"S\")\n    S_ages = subpart(SIR, S, :age)\n\n    λ = λ[S_ages]\n\n    S = bernoulli_sample(S, λ, Δt)\n    queue_state_update(SIR, S, \"I\")\nend","category":"page"},{"location":"examples/sir-age/","page":"SIR example with age structure","title":"SIR example with age structure","text":"The recovery process is the same as in the basic SIR tutorial.","category":"page"},{"location":"examples/sir-age/","page":"SIR example with age structure","title":"SIR example with age structure","text":"function recovery_process(t::Int)\n    I = get_index_state(SIR, \"I\")\n    I = bernoulli_sample(I, γ, Δt)\n    queue_state_update(SIR, I, \"R\")\nend","category":"page"},{"location":"examples/sir-age/#Simulation","page":"SIR example with age structure","title":"Simulation","text":"","category":"section"},{"location":"examples/sir-age/","page":"SIR example with age structure","title":"SIR example with age structure","text":"We use render_process to create a rendering (output) process and a matrix giving state counts by time step. Then we pass the necessary processes to simulation_loop to draw a trajectory and plot the results.","category":"page"},{"location":"examples/sir-age/","page":"SIR example with age structure","title":"SIR example with age structure","text":"state_out, render_process = render_states(SIR, steps)\n\nsimulation_loop(SIR, [infection_process, recovery_process, render_process], steps)\n\nplot(\n    (1:steps) * Δt,\n    state_out,\n    label=[\"S\" \"I\" \"R\"],\n    xlabel=\"Time\",\n    ylabel=\"Number\"\n)","category":"page"},{"location":"examples/sir-age/","page":"SIR example with age structure","title":"SIR example with age structure","text":"We can also plot the size of the epidemic in each age bin, using a stacked bar chart.","category":"page"},{"location":"examples/sir-age/","page":"SIR example with age structure","title":"SIR example with age structure","text":"ever_infected = vcat(incident(SIR, [2, 3], :state)...)\never_infected_ages = subpart(SIR, ever_infected, :age)\never_infected_ages = [sum(ever_infected_ages .== i) for i = 1:16]\n\nbar(pop_TW, label = false, xlabel = \"Age bins\", ylabel = \"Number\")\nbar!(ever_infected_ages, label = false)","category":"page"},{"location":"contributing/#ref_contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Thank you for taking the time to contribute to Individual.jl!","category":"page"},{"location":"contributing/#Issues","page":"Contributing","title":"Issues","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"If you find a bug, have a question about how to use a feature that does not have sufficient documentation, or have a suggestion for improvement, please leave an issue at our GitHub repo.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"For bug reports please include:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Individual.jl version\nOperating System\nJulia version\nSteps to recreate\nExpected behaviour\nActual behaviour","category":"page"},{"location":"contributing/#Git","page":"Contributing","title":"Git","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"We use Git on this project. Which means we use main, dev, feat/*, bug/*, and hotfix/* branches. Please refer to this post for more information of each type of branch. ","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"main: this branch always stores the last release of the software, and is a protected branch. A pull request should","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"not be submitted to main unless it is from dev, meaning that the software version should be updated.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"dev: all pull requests from users should be made to the dev branch. This branch is protected from deletion.\nfeat: new and significantly enhanced features are made in feat branches before being merged with dev. After a feat/* branch is merged with dev, it can be deleted.\nbug: these branches fix bugs, usually after being raised as an issue. After a bug/* branch is merged with dev, it can be deleted.\nhotfix: the difference between a bug/* and hotfix/* branch is hotfix is for small quick fixes (misspellings, incorrect arguments, etc), and can be directly merged into main. After they are merged, it can be deleted.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"We periodically merge dev into main for release updates.","category":"page"},{"location":"contributing/#Continuous-integration","page":"Contributing","title":"Continuous integration","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"We use GitHub Actions as our continuous integration platform to run workflows. We run several types of workflows:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Test checks run during any pull request to [main, dev] branches.\nDocumentation building only runs on pushes to main, which will occur when dev is merged with main.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Please note that sometimes hard to diagnose bugs can be due to out of date workflows. If you find a strange or unusual bug coming from a workflow, this is something to consider checking.","category":"page"},{"location":"contributing/#Pull-requests","page":"Contributing","title":"Pull requests","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"If making a pull request, please only use dev as the base branch. If you are adding a new feature (i.e. the pull is from a feat/* branch), please ensure you have added minimal tests using testthat so that the functionality of your feature can be tested.","category":"page"},{"location":"#Introduction","page":"Individual.jl","title":"Introduction","text":"","category":"section"},{"location":"","page":"Individual.jl","title":"Individual.jl","text":"Individual.jl is a Julia package for specifying and simulating individual-based models (IBMs), using applied category theory. The package relies on Catlab.jl, especially attributed C-Sets to create schemas which can represent a broad class of IBMs useful for epidemiology, ecology, and the computational social sciences. It is inspired by the R software individual.","category":"page"},{"location":"#Documentation","page":"Individual.jl","title":"Documentation","text":"","category":"section"},{"location":"","page":"Individual.jl","title":"Individual.jl","text":"For tutorials on how to use the software, see the examples:","category":"page"},{"location":"","page":"Individual.jl","title":"Individual.jl","text":"start by reading a basic SIR model tutorial here\nread about using event scheduling for events which occur after a non-Geometric delay with an SIR model using event scheduling here\nlearn how to extend the types in Individual.jl with additional attributes, via a SIR model with age-structure here","category":"page"},{"location":"","page":"Individual.jl","title":"Individual.jl","text":"The API reference contains information about objects and functions available to users.","category":"page"},{"location":"#Design","page":"Individual.jl","title":"Design","text":"","category":"section"},{"location":"","page":"Individual.jl","title":"Individual.jl","text":"Individual.jl uses ACSets based on schemas to provide data structures well-suited for individual-based models. Every schema has the objects Person and State, and a morphism from people to states, and may have additional objects and morphisms as required to implement additional functionality, such as event scheduling. ACSets are the data structures that turn these rather abstract schemas into useful tools for computing with, and each schema in Individual.jl comes with an associated ACSet type so that methods can be written for a type hierarchy. For more information about ACSets, please see the paper \"Categorical Data Structures for Technical Computing\" and the AlgebraicJulia blog.","category":"page"},{"location":"#Simulation","page":"Individual.jl","title":"Simulation","text":"","category":"section"},{"location":"","page":"Individual.jl","title":"Individual.jl","text":"Each time step follows a specific order of computation to build consistent models. First, functions called processes are run, which take the current time step as an argument. These may query state, and queue state updates or schedule events, but cannot update state. Next (if being used) events are processed, meaning any event whose delay is currently 0 is \"fired\", and a set of associated functions called event listeners is called for the set of persons experiencing that event. Much like processes, event listeners can queue state updates and schedule future events. Next, the delay on all events is decremented by one. Finally, all queued state updates are applied.","category":"page"},{"location":"","page":"Individual.jl","title":"Individual.jl","text":"The simulation loop ensures that models in Individual.jl follow a synchronous updating scheme (i.e. all state is updated simultaneously at the end of a time step).","category":"page"},{"location":"#Alternatives","page":"Individual.jl","title":"Alternatives","text":"","category":"section"},{"location":"","page":"Individual.jl","title":"Individual.jl","text":"Another framework for individual-based modeling in Julia is Agents.jl. You might prefer to use that package if your model assumes a continuous space, or a lattice grid, and also if you want to use the advanced visualization and app-generation tools in that package. You might prefer to use Individual.jl if your model considers space as a network or metapopulation (if it explicitly includes space at all), or if you would like to take advantage of the ACSet data type for your simulations.","category":"page"},{"location":"#Contributing","page":"Individual.jl","title":"Contributing","text":"","category":"section"},{"location":"","page":"Individual.jl","title":"Individual.jl","text":"Please see the contribution guide here.","category":"page"},{"location":"#Acknowledgements","page":"Individual.jl","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Individual.jl","title":"Individual.jl","text":"Individual.jl is written and maintained by Sean L. Wu (@slwu89).","category":"page"},{"location":"","page":"Individual.jl","title":"Individual.jl","text":"We acknowledge help and advice from Sophie Libkind and Evan Patterson regarding use of Catlab's ACSets.","category":"page"},{"location":"examples/sir-scheduling/","page":"SIR example with event scheduling","title":"SIR example with event scheduling","text":"EditURL = \"https://github.com/slwu89/Individual.jl/blob/main/examples/sir-scheduling.jl\"","category":"page"},{"location":"examples/sir-scheduling/#sir_scheduling","page":"SIR example with event scheduling","title":"SIR example with event scheduling","text":"","category":"section"},{"location":"examples/sir-scheduling/","page":"SIR example with event scheduling","title":"SIR example with event scheduling","text":"Sean L. Wu (@slwu89), 2021-1-9","category":"page"},{"location":"examples/sir-scheduling/","page":"SIR example with event scheduling","title":"SIR example with event scheduling","text":"using Individual.Sampling\nusing Individual.SchemaBase\nusing Individual.SchemaEvents\n\nusing Catlab.Present, Catlab.CSetDataStructures, Catlab.Theories, Catlab.CategoricalAlgebra, Catlab.Graphics, Catlab.Graphs\nusing Plots\nusing GraphViz","category":"page"},{"location":"examples/sir-scheduling/#Introduction","page":"SIR example with event scheduling","title":"Introduction","text":"","category":"section"},{"location":"examples/sir-scheduling/","page":"SIR example with event scheduling","title":"SIR example with event scheduling","text":"This tutorial shows how to simulate the SIR model using the event scheduling schema available in Individual.jl. The stochastic process being simulated is exactly the same as the basic Markov SIR model tutorial, and all parameters are identical, so please see that tutorial for reference if needed.","category":"page"},{"location":"examples/sir-scheduling/","page":"SIR example with event scheduling","title":"SIR example with event scheduling","text":"The schema looks like this:","category":"page"},{"location":"examples/sir-scheduling/","page":"SIR example with event scheduling","title":"SIR example with event scheduling","text":"to_graphviz(TheorySchedulingIBM)","category":"page"},{"location":"examples/sir-scheduling/","page":"SIR example with event scheduling","title":"SIR example with event scheduling","text":"The schema expands on the basic TheoryIBM for Markov models; the relationship between states and people is the same. There is a new object, Event, which in epidemiological models might contain recovery, hospitalization, death, etc. There are morphisms into the objects EventLabel and EventListener. EventLabel is simply a string for writing self-documenting models. The EventListener stores functions called \"event listeners\" which are called with the set of persons scheduled for that event on that timestep, and may queue state updates, and schedule or cancel other events.","category":"page"},{"location":"examples/sir-scheduling/","page":"SIR example with event scheduling","title":"SIR example with event scheduling","text":"The set of scheduled (queued) events is also an object Scheduled, with morphisms into the objects of events and persons, and a delay attribute. For each queued event these tell us which event will occur, who it will happen to, and after how many timesteps it (the event listener) should fire. This event scheduling mechanism allows events which occur after a non-Geometric (i.e. non-Markovian) delay, such as fixed delays or any other distribution.","category":"page"},{"location":"examples/sir-scheduling/","page":"SIR example with event scheduling","title":"SIR example with event scheduling","text":"If we had additional combinatorial data describing each person (e.g. discrete age bin for each person), we could make another attribute and a morphism from people to that attribute. Additional atomic data for each person (e.g. neutralizing antibody titre) would be an attribute of people. In this way we can simulate a general class of individual based models relevant to epidemiology, ecology, and the social sciences.","category":"page"},{"location":"examples/sir-scheduling/#Parameters","page":"SIR example with event scheduling","title":"Parameters","text":"","category":"section"},{"location":"examples/sir-scheduling/","page":"SIR example with event scheduling","title":"SIR example with event scheduling","text":"N = 1000\nI0 = 8\nS0 = N - I0\nΔt = 0.1\ntmax = 100\nsteps = Int(tmax/Δt)\nγ = 1/10 # recovery rate\nR0 = 2.5\nβ = R0 * γ # R0 for corresponding ODEs\n\ninitial_states = fill(\"S\", N)\ninitial_states[rand(1:N, I0)] .= \"I\"\nstate_labels = [\"S\", \"I\", \"R\"];\nnothing #hide","category":"page"},{"location":"examples/sir-scheduling/#Model-object","page":"SIR example with event scheduling","title":"Model object","text":"","category":"section"},{"location":"examples/sir-scheduling/","page":"SIR example with event scheduling","title":"SIR example with event scheduling","text":"The \"SchedulingIBM\" (Individual Based Model with Scheduling) schema needs several type parameters. The first is the same as the \"IBM\" schema, associating a unique name to each categorical state. The second is the delay, the number of time steps after which a scheduled event will fire. The third is the name for each event. The last is for the listeners associated with each event.","category":"page"},{"location":"examples/sir-scheduling/","page":"SIR example with event scheduling","title":"SIR example with event scheduling","text":"const SIR = SchedulingIBM{String, Int64, String, Vector{Function}}()\ninitialize_states(SIR, initial_states, state_labels);\nnothing #hide","category":"page"},{"location":"examples/sir-scheduling/#Processes","page":"SIR example with event scheduling","title":"Processes","text":"","category":"section"},{"location":"examples/sir-scheduling/","page":"SIR example with event scheduling","title":"SIR example with event scheduling","text":"The infection process is the same as the basic SIR model.","category":"page"},{"location":"examples/sir-scheduling/","page":"SIR example with event scheduling","title":"SIR example with event scheduling","text":"function infection_process(t::Int)\n    I = npeople(SIR, \"I\")\n    N = npeople(SIR)\n    λ = β * I/N\n    S = get_index_state(SIR, \"S\")\n    S = bernoulli_sample(S, λ, Δt)\n    queue_state_update(SIR, S, \"I\")\nend","category":"page"},{"location":"examples/sir-scheduling/","page":"SIR example with event scheduling","title":"SIR example with event scheduling","text":"The recovery process is queues future recovery events. We first find who is infected, and then take the set difference of those persons with those who are already scheduled for recovery, which is just the set of persons who need a recovery scheduled.","category":"page"},{"location":"examples/sir-scheduling/","page":"SIR example with event scheduling","title":"SIR example with event scheduling","text":"function recovery_process(t::Int)\n\n    I = get_index_state(SIR, \"I\")\n    already_scheduled = get_scheduled(SIR, \"Recovery\")\n    to_schedule = setdiff(I, already_scheduled)\n\n    if length(to_schedule) > 0\n        rec_times = delay_geom_sample(length(to_schedule), γ, Δt)\n        schedule_event(SIR, to_schedule, rec_times, \"Recovery\")\n    end\nend","category":"page"},{"location":"examples/sir-scheduling/#Events","page":"SIR example with event scheduling","title":"Events","text":"","category":"section"},{"location":"examples/sir-scheduling/","page":"SIR example with event scheduling","title":"SIR example with event scheduling","text":"The event listener associated with recovery is quite simple, just updating the state to R. We create an event with the label \"Recovery\" and a single listener, and add it to the model.","category":"page"},{"location":"examples/sir-scheduling/","page":"SIR example with event scheduling","title":"SIR example with event scheduling","text":"function recovery_listener(target, t::Int)\n    queue_state_update(SIR, target, \"R\")\nend\n\nadd_event(SIR, \"Recovery\", recovery_listener);\nnothing #hide","category":"page"},{"location":"examples/sir-scheduling/#Simulation","page":"SIR example with event scheduling","title":"Simulation","text":"","category":"section"},{"location":"examples/sir-scheduling/","page":"SIR example with event scheduling","title":"SIR example with event scheduling","text":"We use render_process to create a rendering (output) process and a matrix giving state counts by time step. Then we draw a trajectory and plot the results. We need to use the simulation_loop from the module for models with event scheduling.","category":"page"},{"location":"examples/sir-scheduling/","page":"SIR example with event scheduling","title":"SIR example with event scheduling","text":"state_out, render_process = render_states(SIR, steps)\n\nsimulation_loop(SIR, [infection_process, recovery_process, render_process], steps)\n\nplot(\n    (1:steps) * Δt,\n    state_out,\n    label=[\"S\" \"I\" \"R\"],\n    xlabel=\"Time\",\n    ylabel=\"Number\"\n)","category":"page"}]
}
